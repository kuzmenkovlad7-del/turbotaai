import { NextRequest, NextResponse } from "next/server"
import crypto from "crypto"
import { cookies } from "next/headers"
import { createServerClient } from "@supabase/ssr"
import { getSupabaseAdmin } from "@/lib/supabase-admin"

export const runtime = "nodejs"
export const dynamic = "force-dynamic"

const DEVICE_COOKIE = "turbotaai_device"

function pickEnv(...keys: string[]) {
  for (const k of keys) {
    const v = process.env[k]
    if (v && String(v).trim()) return String(v).trim()
  }
  return ""
}

function getOrigin(req: NextRequest) {
  const proto = req.headers.get("x-forwarded-proto") || "https"
  const host = req.headers.get("x-forwarded-host") || req.headers.get("host")
  if (host) return `${proto}://${host}`
  return new URL(req.url).origin
}

function hmacMd5Hex(secret: string, data: string) {
  return crypto.createHmac("md5", secret).update(data, "utf8").digest("hex")
}

function planConfig(plan: string | null) {
  const p = (plan || "monthly").toLowerCase()
  if (p === "monthly") {
    return {
      plan: "monthly",
      amount: 499,
      currency: "UAH",
      days: 30,
      productName: "TurbotaAI Monthly",
    }
  }
  return {
    plan: "monthly",
    amount: 499,
    currency: "UAH",
    days: 30,
    productName: "TurbotaAI Monthly",
  }
}

function getTestAmount(defaultAmount: number) {
  const raw = String(process.env.WAYFORPAY_TEST_AMOUNT || "").trim()
  const n = Number(raw)
  if (!raw) return defaultAmount
  if (!Number.isFinite(n)) return defaultAmount
  if (n <= 0) return defaultAmount
  return Math.floor(n)
}

async function getUserIdFromSession() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  if (!url || !anon) return null

  const cookieStore = cookies()
  const sb = createServerClient(url, anon, {
    cookies: {
      getAll() {
        return cookieStore.getAll()
      },
      setAll() {},
    },
  })

  const { data } = await sb.auth.getUser()
  return data?.user?.id || null
}

async function handle(req: NextRequest) {
  const origin = getOrigin(req)

  const merchantAccount = pickEnv(
    "WAYFORPAY_MERCHANT_ACCOUNT",
    "WAYFORPAY_ACCOUNT",
    "WFP_MERCHANT_ACCOUNT"
  )

  const secretKey = pickEnv(
    "WAYFORPAY_MERCHANT_SECRET_KEY",
    "WAYFORPAY_SECRET_KEY",
    "WAYFORPAY_SECRET",
    "WFP_SECRET_KEY"
  )

  if (!merchantAccount || !secretKey) {
    return NextResponse.json(
      { ok: false, error: "WayForPay env missing: merchant account / secret key" },
      { status: 500 }
    )
  }

  const cookieStore = cookies()

  let deviceHash = cookieStore.get(DEVICE_COOKIE)?.value ?? null
  let needSetDeviceCookie = false
  if (!deviceHash) {
    deviceHash = crypto.randomUUID()
    needSetDeviceCookie = true
  }

  const userId = await getUserIdFromSession().catch(() => null)

  const planId = String(req.nextUrl.searchParams.get("planId") || "monthly").trim()
  const cfgRaw = planConfig(planId)

  // тестовая сумма через env, чтобы гонять оплату за 1 грн
  const cfg = {
    ...cfgRaw,
    amount: getTestAmount(cfgRaw.amount),
  }

  const orderReference = `ta_${cfg.plan}_${Date.now()}_${crypto.randomBytes(4).toString("hex")}`
  const orderDate = Math.floor(Date.now() / 1000)

  const merchantDomainName =
    pickEnv("WAYFORPAY_MERCHANT_DOMAIN_NAME", "WAYFORPAY_DOMAIN") ||
    new URL(origin).host

  const productName = [cfg.productName]
  const productCount = [1]
  const productPrice = [cfg.amount]

  const signString = [
    merchantAccount,
    merchantDomainName,
    orderReference,
    String(orderDate),
    String(cfg.amount),
    cfg.currency,
    ...productName.map(String),
    ...productCount.map((x) => String(x)),
    ...productPrice.map((x) => String(x)),
  ].join(";")

  const merchantSignature = hmacMd5Hex(secretKey, signString)

  // ВАЖНО: return page у нас /payment/result
  const returnUrl = `${origin}/payment/result?orderReference=${encodeURIComponent(orderReference)}`
  const serviceUrl = `${origin}/api/billing/wayforpay/webhook`

  const payload = {
    transactionType: "CREATE_INVOICE",
    merchantAccount,
    merchantDomainName,
    merchantSignature,
    apiVersion: 1,
    orderReference,
    orderDate,
    amount: cfg.amount,
    currency: cfg.currency,
    productName,
    productCount,
    productPrice,
    serviceUrl,
    returnUrl,
    language: "UA",
  }

  let wfp: any = null
  try {
    const r = await fetch("https://api.wayforpay.com/api", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload),
      cache: "no-store",
    })
    wfp = await r.json()
  } catch (e: any) {
    return NextResponse.json(
      { ok: false, error: "WayForPay request failed", details: String(e?.message || e) },
      { status: 500 }
    )
  }

  const invoiceUrl = wfp?.invoiceUrl || wfp?.payUrl || wfp?.url || null
  if (!invoiceUrl) {
    return NextResponse.json({ ok: false, error: "WayForPay invoiceUrl missing", wfp }, { status: 500 })
  }

  // сохраняем order в billing_orders, чтобы webhook/status могли корректно выдать доступ
  try {
    const admin = getSupabaseAdmin()
    const nowIso = new Date().toISOString()

    await admin.from("billing_orders").insert({
      order_reference: orderReference,
      user_id: userId,
      device_hash: deviceHash,
      plan_id: cfg.plan,
      amount: cfg.amount,
      currency: cfg.currency,
      status: "invoice_created",
      raw: { request: payload, response: wfp },
      created_at: nowIso,
      updated_at: nowIso,
    } as any)
  } catch (e) {
    console.error("[billing][purchase] insert billing_orders failed", e)
  }

  // ДЕЛАЕМ РЕДИРЕКТ В ОПЛАТУ
  const res = NextResponse.redirect(invoiceUrl, 302)

  // фиксируем device cookie в едином ключе turbotaai_device
  if (needSetDeviceCookie) {
    res.cookies.set(DEVICE_COOKIE, deviceHash!, {
      path: "/",
      sameSite: "lax",
      httpOnly: false,
      maxAge: 60 * 60 * 24 * 365,
    })
  }

  res.cookies.set("ta_last_order_reference", orderReference, { path: "/", maxAge: 60 * 30 })
  res.headers.set("cache-control", "no-store, max-age=0")

  return res
}

export async function GET(req: NextRequest) {
  return handle(req)
}

export async function POST(req: NextRequest) {
  return handle(req)
}
